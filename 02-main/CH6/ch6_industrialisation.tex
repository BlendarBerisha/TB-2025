% =============================================================
% Chapitre 6 — Industrialisation et mise en production
% =============================================================

\chapter{Industrialisation et mise en production}
\label{chap:industrialisation}

Ce chapitre décrit la chaîne d’intégration et de livraison recommandée pour les visuels personnalisés. Le périmètre est la diffusion interne via le magasin organisationnel ; la place de marché publique n’entre pas dans le dispositif. L’objectif est de produire, à chaque version, un paquet pbiviz fiable, reproductible et vérifiable, afin que la décision de publication repose sur des éléments objectifs.

% -------------------------------------------------------------
\section{Cadre général}
\label{sec:ci-cadre}

La chaîne d’industrialisation poursuit trois finalités. D’abord, garantir qu’un même code aboutit au même artefact, indépendamment de l’environnement où il est construit. Ensuite, détecter le plus tôt possible toute régression fonctionnelle ou de sécurité pour éviter de la déplacer vers l’aval. Enfin, fournir avec chaque paquet des preuves simples — audit, empreinte d’intégrité, journal des modifications — qui permettent une revue rapide et une diffusion maîtrisée dans le magasin organisationnel.

Le dispositif sépare clairement la construction technique et la préparation à la diffusion. Les étapes répétitives et sensibles aux erreurs humaines sont automatisées : installation déterministe des dépendances, tests, audit de packaging, contrôles de seuils, génération et archivage des artefacts. Les responsabilités sont réparties de manière à éviter les angles morts : développement pour la qualité du code, intégration pour la production des artefacts, administration pour la décision de publication.

% -------------------------------------------------------------
\section{Notions utiles}
\label{sec:definitions}

Le magasin organisationnel est la galerie privée de visuels du tenant. Y publier un composant le rend disponible aux créateurs de rapports sans manipulation de fichiers locaux.

L’audit automatisé est l’analyse fournie par l’outillage officiel au moment du packaging ; il signale des pratiques susceptibles de dégrader l’exécution dans le service et sert de garde-fou même sans objectif de certification publique.

L’empreinte SHA-256 est une somme de contrôle jointe à la release ; elle prouve que le fichier n’a pas été modifié après sa production. La signature interne est une option de gouvernance : une signature cryptographique produite lors de la release pour attester l’origine du paquet. Elle n’est pas requise pour l’import dans le magasin organisationnel. Sa mise en œuvre opérationnelle figure en annexe~\ref{ann:signature-procedure}.

% -------------------------------------------------------------
\section{Exigences de la chaîne}
\label{sec:exigences-ci}

Les workflows s’exécutent sous Node~LTS~22. Les dépendances sont installées de manière déterministe avec \texttt{npm ci}. Le packaging s’appuie sur l’outillage officiel et active l’audit de certification afin de détecter les usages non supportés. Un seuil de couverture minimale des tests (déclarations) est appliqué (par défaut~\(\geq\)~70\,\%). La taille du paquet est contrôlée pour préserver les temps de chargement (\(\leq\)~1\,MiB). Chaque release met à disposition le paquet pbiviz, son empreinte SHA-256, le rapport d’audit et le journal des modifications ; la signature interne, lorsqu’elle est adoptée, s’y ajoute. Ces contrôles s’alignent sur les critères transverses du projet (performance, accessibilité, sécurité).

% -------------------------------------------------------------
\section{Chaîne d’intégration et de livraison}
\label{sec:ci-cd}

Chaque dépôt héberge un unique visuel. La chaîne repose sur deux workflows GitHub Actions complémentaires : un build continu (sur \textit{push} et \textit{pull request}) et une release sur marquage de version.

\subsection{Build continu}
\label{subsec:ci-build}

\noindent\textbf{Workflow de build et packaging (un visuel par dépôt)}
\begin{verbatim}
name: ci-build

on:
  push: { branches: [ "master" ] }
  pull_request: { branches: [ "master" ] }
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-24.04
    permissions:
      contents: read
    concurrency:
      group: build-${{ github.ref }}
      cancel-in-progress: true
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'npm'

      - name: Install deps
        run: npm ci

      - name: Lint (log non bloquant)
        shell: bash
        run: |
          mkdir -p dist
          npm run lint -- --verbose 2>&1 \
            | tee dist/eslint.log || true

      - name: Ensure webpack & loaders (no-save)
        shell: bash
        run: |
          set -e
          npm ls webpack >/dev/null 2>&1 || \
            npm install --no-save -D webpack webpack-cli
          npm ls ts-loader >/dev/null 2>&1 || \
            npm install --no-save -D ts-loader
          npm ls css-loader >/dev/null 2>&1 || \
            npm install --no-save -D css-loader
          npm ls json-loader >/dev/null 2>&1 || \
            npm install --no-save -D json-loader
          npm ls less-loader >/dev/null 2>&1 || \
            npm install --no-save -D less less-loader
          npm ls typescript >/dev/null 2>&1 || \
            npm install --no-save -D typescript

      - name: Tests et couverture minimale
        shell: bash
        env:
          MIN_COVERAGE: "70"
        run: |
          npm test -- --ci --coverage --passWithNoTests \
            --coverageReporters=json-summary \
            --coverageReporters=text \
            --coverageReporters=lcov || true
          if [ -f coverage/coverage-summary.json ]; then
            COVER=$(node -e "const s=require('./coverage/coverage-summary.json'); \
process.stdout.write(String(s.total.statements.pct||0))")
          else
            COVER=0
          fi
          echo "Coverage (statements): ${COVER}% (min: ${MIN_COVERAGE}%)"
          awk -v c="$COVER" -v min="$MIN_COVERAGE" \
            'BEGIN{ exit (c+0 < min+0) }'

      - name: Packaging avec audit (log capturé)
        shell: bash
        run: |
          mkdir -p dist
          npx --yes --package powerbi-visuals-tools \
            pbiviz package --certification-audit \
            2>&1 | tee dist/packaging.log

      - name: Contrôle de taille du paquet
        shell: bash
        run: |
          shopt -s nullglob
          files=(dist/*.pbiviz)
          if [ ${#files[@]} -eq 0 ]; then
            echo "Aucun paquet .pbiviz produit"; exit 1
          fi
          max=0
          for f in "${files[@]}"; do
            size=$(wc -c <"$f")
            [ "$size" -gt "$max" ] && max=$size
          done
          echo "Max bundle size: $max bytes"
          [ "$max" -le 1048576 ]  # 1 MiB cible

      - uses: actions/upload-artifact@v4
        with:
          name: pbiviz-build
          path: |
            dist/*.pbiviz
            dist/packaging.log
            dist/eslint.log
            coverage/coverage-summary.json
            coverage/lcov.info
          retention-days: 14
\end{verbatim}

\subsection{Release sur tag}
\label{subsec:ci-release}

La release reconstruit avec audit, calcule l’empreinte d’intégrité et publie les artefacts destinés à l’administrateur. Le déclenchement repose sur un marquage de version respectant SemVer (format \texttt{vMAJ.MIN.PATCH}, par exemple \texttt{v1.3.0}). Par défaut, aucune signature n’est produite ; l’option de signature interne est décrite en annexe~\ref{ann:signature-procedure}.

\noindent\textbf{Workflow de release (empreinte d’intégrité, un visuel par dépôt)}
\begin{verbatim}
name: ci-release

on:
  push: { tags: [ "v*" ] }

jobs:
  release:
    runs-on: ubuntu-24.04
    concurrency:
      group: release-${{ github.ref }}
      cancel-in-progress: false
    permissions:
      contents: write

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'npm'

      - run: npm ci

      - name: Vérifier cohérence version/tag
        shell: bash
        run: |
          TAG="${GITHUB_REF_NAME#v}"
          PKG=$(node -p "require('./package.json').version")
          echo "Tag: $TAG / package.json: $PKG"
          [ "$TAG" = "$PKG" ] || { \
            echo "Version et tag incohérents"; exit 1; }

      - name: Ensure webpack & loaders (no-save)
        shell: bash
        run: |
          set -e
          npm ls webpack >/dev/null 2>&1 || \
            npm install --no-save -D webpack webpack-cli
          npm ls ts-loader >/dev/null 2>&1 || \
            npm install --no-save -D ts-loader
          npm ls css-loader >/dev/null 2>&1 || \
            npm install --no-save -D css-loader
          npm ls json-loader >/dev/null 2>&1 || \
            npm install --no-save -D json-loader
          npm ls less-loader >/dev/null 2>&1 || \
            npm install --no-save -D less less-loader
          npm ls typescript >/dev/null 2>&1 || \
            npm install --no-save -D typescript

      - name: Packaging avec audit (log capturé)
        shell: bash
        run: |
          mkdir -p dist
          npx --yes --package powerbi-visuals-tools \
            pbiviz package --certification-audit \
            2>&1 | tee dist/packaging.log

      - name: Empreinte SHA-256
        shell: bash
        run: |
          shopt -s nullglob
          files=(dist/*.pbiviz)
          if [ ${#files[@]} -eq 0 ]; then
            echo "Aucun paquet .pbiviz produit"; exit 1
          fi
          for f in "${files[@]}"; do
            sha256sum "$f" > "$f.sha256"
            echo "SHA256($(basename "$f")): \
$(cut -d' ' -f1 "$f.sha256")"
          done

      - name: Signature (.p7s) si secrets présents
        shell: bash
        env:
          ECRINS_CODESIGN_CRT: ${{ secrets.ECRINS_CODESIGN_CRT }}
          ECRINS_CODESIGN_KEY: ${{ secrets.ECRINS_CODESIGN_KEY }}
          ECRINS_CODESIGN_PASS: ${{ secrets.ECRINS_CODESIGN_PASS }}
        run: |
          set -e
          shopt -s nullglob
          files=(dist/*.pbiviz)
          if [ ${#files[@]} -eq 0 ]; then
            echo "Aucun paquet .pbiviz produit"; exit 1
          fi
          if [ -z "${ECRINS_CODESIGN_CRT:-}" ] || \
             [ -z "${ECRINS_CODESIGN_KEY:-}" ] || \
             [ -z "${ECRINS_CODESIGN_PASS:-}" ]; then
            echo "Secrets de signature absents → skip signature."
            exit 0
          fi
          printf "%s" "$ECRINS_CODESIGN_CRT" > dist/_codesign.crt
          printf "%s" "$ECRINS_CODESIGN_KEY" > dist/_codesign.key
          for f in "${files[@]}"; do
            openssl smime -sign -binary \
              -in "$f" \
              -signer dist/_codesign.crt \
              -inkey dist/_codesign.key \
              -passin env:ECRINS_CODESIGN_PASS \
              -outform DER -out "$f.p7s"
            echo "Signed: $(basename "$f").p7s"
          done

      - uses: actions/upload-artifact@v4
        with:
          name: pbiviz-release-${{ github.ref_name }}
          path: |
            dist/*.pbiviz
            dist/*.sha256
            dist/*.p7s
            dist/packaging.log
          retention-days: 90

      - uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ github.ref_name }}
          name: ${{ github.ref_name }}
          files: dist/*
          generate_release_notes: true
\end{verbatim}

% -------------------------------------------------------------
\section{Intégrité et signature}
\label{sec:signature-principes}

L’empreinte SHA-256 permet de vérifier, avant publication, que le fichier reçu est identique à celui produit par la chaîne. Toute divergence impose de refuser la diffusion et de demander une nouvelle release.

La signature interne est une option destinée à renforcer l’attribution en prouvant que la release provient du pipeline autorisé. Elle n’est pas requise pour l’import dans le magasin organisationnel. Son activation, son exploitation et son renouvellement sont décrits en annexe~\ref{ann:signature-procedure} ; lorsque cette option est en place, un fichier \texttt{.p7s} accompagne le paquet et son empreinte.

% -------------------------------------------------------------
\section{Diffusion dans le magasin organisationnel}
\label{sec:distribution}

La diffusion s’effectue dans le magasin organisationnel après vérifications préalables. L’administrateur ajoute le paquet validé à la galerie interne afin qu’il soit disponible aux créateurs de rapports. La procédure pas à pas — contrôles, publication et retour arrière — est décrite en annexe~\ref{ann:org-store-procedure}.

% -------------------------------------------------------------
\section{Impacts et limites}
\label{sec:limitations}

Une diffusion interne sans certification publique peut limiter certaines fonctions du service dans des cas particuliers, notamment l’export de pages contenant des visuels non certifiés. Ces limites doivent être portées à la connaissance des utilisateurs et, si nécessaire, des vues alternatives sans visuels personnalisés doivent être prévues pour les besoins d’export.

% -------------------------------------------------------------
\section{Rôles et responsabilités}
\label{sec:roles-controle}

Le développement maintient un code testé, lisible et conforme aux règles de style. L’intégration continue orchestre les workflows, exécute l’audit, réalise le packaging et publie les artefacts, l’empreinte et le journal des modifications. L’administration vérifie les éléments de preuve, décide de la publication dans le magasin organisationnel et pilote, le cas échéant, le retour arrière. Le responsable métier valide l’adéquation fonctionnelle avant une diffusion élargie. La décision de mise à disposition appartient à l’administration, après avis du responsable métier et sur la base des preuves fournies par la chaîne.

% -------------------------------------------------------------
\section{Traçabilité et maintenance}
\label{sec:maintenance-transfert}

Chaque release conserve le paquet pbiviz, l’empreinte SHA-256, le rapport d’audit et le journal des modifications, ainsi que la signature lorsque l’option est activée. Cet archivage forme la mémoire technique du produit et facilite l’investigation en cas d’incident. La maintenance couvre la veille des versions de l’API des visuels, la mise à jour contrôlée des dépendances, la reconduction des tests et de l’audit, et la révision périodique des seuils de qualité. Lorsque la signature interne est en place, le renouvellement des certificats et la rotation des secrets sont planifiés dans le même cycle.
